<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JSONDatabase by ST</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <!-- Prism.js CSS (Okaidia Theme) -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" rel="stylesheet" />
    <style>
        /* Basic Reset & Material Font */
        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
        html { scroll-behavior: smooth; font-size: 16px; }
        body { font-family: 'Roboto', sans-serif; line-height: 1.6; color: #333; background-color: #f4f4f4; min-height: 100vh; display: flex; flex-direction: column; }

        /* --- Sidebar --- */
        #sidebar { width: 240px; background-color: #ffffff; border-right: 1px solid #e0e0e0; padding: 20px 0; height: 100vh; position: fixed; top: 0; left: 0; z-index: 1000; overflow-y: auto; transition: left 0.3s ease-in-out; box-shadow: 2px 0 5px rgba(0,0,0,0.1); }
        #sidebar h3 { padding: 10px 20px; font-size: 1.1em; color: #3f51b5; border-bottom: 1px solid #eee; margin-bottom: 10px; }
        #sidebar ul { list-style: none; padding: 0; margin: 0; }
        #sidebar li a { display: block; padding: 10px 20px; color: #424242; text-decoration: none; font-size: 0.95em; transition: background-color 0.2s ease, color 0.2s ease; border-left: 3px solid transparent; }
        #sidebar li a:hover { background-color: #f5f5f5; color: #3f51b5; }
        #sidebar ul ul { margin-left: 15px; } /* Indent nested list */
        #sidebar ul ul a { padding-left: 30px; font-size: 0.9em; color: #616161; }
        #sidebar ul ul a:hover { background-color: #e8eaf6; }

        /* --- Header --- */
        header { background-color: #3f51b5; color: #fff; padding: 15px 0; text-align: center; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); position: sticky; top: 0; z-index: 999; width: 100%; display: flex; align-items: center; justify-content: center; }
        #menu-toggle { display: none; background: none; border: none; color: #fff; font-size: 24px; cursor: pointer; padding: 5px 15px; position: absolute; left: 10px; top: 50%; transform: translateY(-50%); }
        header h1 { margin: 0; font-weight: 500; font-size: 1.6em; }

        /* --- Main Content Area --- */
        .content-wrapper { display: flex; flex-grow: 1; }
        main { flex-grow: 1; padding: 30px 20px 30px 260px; /* Left padding = sidebar width + margin */ width: 100%; transition: padding-left 0.3s ease-in-out; }
        .container { max-width: 900px; margin: 0 auto; width: 100%; }

        /* Cards for Sections */
        .card { background-color: #fff; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24); margin-bottom: 25px; padding: 25px; overflow: hidden; }
        .card h2, .card h3 { color: #3f51b5; margin-bottom: 15px; padding-bottom: 5px; border-bottom: 1px solid #eee; }
        .card h2 { scroll-margin-top: 80px; /* Offset for sticky header */ }
        .card h3 { color: #5c6bc0; margin-top: 20px; margin-bottom: 10px; font-size: 1.3em; scroll-margin-top: 80px; /* Offset for sticky header */ }

        /* Code Blocks */
        pre[class*="language-"] { padding: 1em; margin: 1.5em 0; overflow: auto; border-radius: 6px; background-color: #272822; font-size: 0.95em; }
        code[class*="language-"] { font-family: 'Consolas', 'Monaco', 'Andale Mono', 'Ubuntu Mono', monospace; font-size: 0.95em; }
        :not(pre) > code { background-color: #e8eaf6; color: #3f51b5; padding: 0.2em 0.4em; border-radius: 3px; font-size: 0.9em; }

        /* Params & Props Lists */
        ul.params, ul.props { list-style: none; margin-left: 10px; margin-bottom: 15px; }
        ul.params li, ul.props li { margin-bottom: 10px; padding-left: 20px; position: relative; }
        ul.params li::before, ul.props li::before { content: '•'; position: absolute; left: 0; color: #3f51b5; font-weight: bold; }
        ul.params code, ul.props code { font-weight: 500; }
        .param-type, .prop-type { font-style: italic; color: #757575; margin-left: 5px; }
        .optional { color: #ff9800; font-size: 0.85em; margin-left: 5px; }
        ul.props ul { margin-top: 5px; list-style: disc; margin-left: 25px; } /* Nested list for stats */

        /* Notes */
        .note { background-color: #e3f2fd; border-left: 4px solid #2196f3; padding: 15px; margin: 15px 0; border-radius: 4px; }
        .note strong { color: #1e88e5; }

        /* Footer */
        footer { text-align: center; padding: 20px; margin-top: auto; background-color: #e0e0e0; color: #616161; font-size: 0.9em; padding-left: 240px; /* Default for desktop */ transition: padding-left 0.3s ease-in-out; }
        footer a { color: #3f51b5; text-decoration: none; }
        footer a:hover { text-decoration: underline; }

        /* --- Responsive Design --- */
        @media (max-width: 992px) {
            #sidebar { left: -250px; box-shadow: 4px 0 6px rgba(0,0,0,0.1); height: 100%; position: fixed; top: 0; }
            main { padding-left: 20px; }
            #menu-toggle { display: block; }
            header { justify-content: center; padding-left: 50px; padding-right: 50px; }
            header h1 { font-size: 1.4em; }
            footer { padding-left: 0; }
            body.sidebar-open #sidebar { left: 0; }
            body.sidebar-open::after { content: ''; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0, 0, 0, 0.4); z-index: 999; }
        }
        @media (max-width: 768px) {
             .container { width: 100%; }
             .card { padding: 20px; }
             pre[class*="language-"] { font-size: 0.9em; }
             .card h2, .card h3 { scroll-margin-top: 70px; }
        }
        @media (max-width: 480px) {
             html { font-size: 15px; }
             header h1 { font-size: 1.2em; }
             .card { padding: 15px; }
             pre[class*="language-"] { font-size: 0.85em; }
             ul.params li, ul.props li { padding-left: 15px; }
             ul.params li::before, ul.props li::before { left: -5px; }
        }
    </style>
</head>
<body>

    <aside id="sidebar">
        <h3>Navigation</h3>
        <ul>
            <li><a href="#intro">Introduction</a></li>
            <li><a href="#getting-started">Getting Started</a></li>
            <li><a href="#core-concepts">Core Concepts</a></li>
            <li>
                <a href="#api">API Reference</a>
                <ul> <!-- Nested list for API methods -->
                    <li><a href="#api-constructor">Constructor</a></li>
                    <li><a href="#api-get">get()</a></li>
                    <li><a href="#api-set">set()</a></li>
                    <li><a href="#api-push">push()</a></li>
                    <li><a href="#api-pull">pull()</a></li>
                    <li><a href="#api-delete">delete()</a></li>
                    <li><a href="#api-has">has()</a></li>
                    <li><a href="#api-transaction">transaction()</a></li>
                    <li><a href="#api-batch">batch()</a></li>
                    <li><a href="#api-query">query()</a></li>
                    <li><a href="#api-clear">clear()</a></li>
                    <li><a href="#api-getstats">getStats()</a></li>
                    <li><a href="#api-close">close()</a></li>
                </ul>
            </li>
            <li><a href="#properties">Properties</a></li>
        </ul>
    </aside>

    <div class="content-wrapper">
        <header>
            <button id="menu-toggle" aria-label="Toggle Menu">☰</button> <!-- Hamburger Icon -->
            <h1>Simple JSON DB</h1>
        </header>

        <main>
            <div class="container">

                <!-- Introduction Card -->
                <section id="intro" class="card">
                    <h2>Introduction</h2>
                     <p>
                         A simple, promise-based JSON file database for Node.js with atomic operations, transactions, and lodash integration.
                     </p>
                     <p>
                        <code>json-database-st</code> provides a straightforward interface for managing data stored in a single JSON file. It's designed for Node.js environments and offers features like:
                    </p>
                    <ul>
                        <li><strong>Atomic Operations:</strong> Ensures write operations are indivisible, preventing data corruption.</li>
                        <li><strong>Caching:</strong> In-memory cache for faster reads after initial load.</li>
                        <li><strong>Transactions:</strong> Group multiple operations into a single atomic unit.</li>
                        <li><strong>Batching:</strong> Efficiently perform multiple write operations together.</li>
                        <li><strong>Querying:</strong> Basic filtering capabilities based on object properties.</li>
                        <li><strong>Simplicity:</strong> Uses lodash for robust data manipulation via dot/array notation paths.</li>
                    </ul>

                    <h3>Dependencies</h3>
                    <p>This module requires:</p>
                    <ul>
                        <li>Node.js (v14.0.0 or higher recommended for stable `fs.promises`)</li>
                        <li><a href="https://lodash.com/" target="_blank" rel="noopener">lodash</a> library (peer dependency)</li>
                    </ul>

                    <h3>Installation</h3>
                    <p>Install the package and its required peer dependency `lodash` using npm or yarn:</p>
                    <pre><code class="language-bash">npm install json-database-st lodash</code></pre>
                    <p>Then, require the library in your project:</p>
                    <pre><code class="language-javascript">const JSONDatabase = require('json-database-st');</code></pre>
                </section>

                <!-- Getting Started Card -->
                <section id="getting-started" class="card">
                    <h2>Getting Started</h2>
                    <p>Here's a basic example of how to use the database:</p>
                    <pre><code class="language-javascript">// main.js
const JSONDatabase = require('json-database-st');
const path = require('path');

// Create or load 'my_database.json' in a 'data' subdirectory
// '.json' is added automatically if omitted
const db = new JSONDatabase(path.join(__dirname, 'data', 'my_database'), { prettyPrint: true });

async function main() {
    try {
        // The constructor initiates loading, but operations await initialization internally
        console.log('Database targeting file:', db.filename);

        // Set some initial data
        await db.set('user.name', 'Alice');
        await db.set('user.age', 30);
        await db.set('products', []);

        console.log('Set initial data.');

        // Push items (deep comparison ensures uniqueness)
        await db.push('products', { id: 'a1', name: 'apple' }, { id: 'b2', name: 'banana' });
        await db.push('products', { id: 'c3', name: 'orange' }, { id: 'a1', name: 'apple' }); // apple obj won't be added again

        // Get data
        const userName = await db.get('user.name');
        const products = await db.get('products');
        const userAge = await db.get('user.age', 25); // Default value if not found
        const nonExistent = await db.get('user.address', 'N/A');

        console.log(`User Name: ${userName}`); // Output: User Name: Alice
        console.log(`User Age: ${userAge}`);   // Output: User Age: 30
        console.log(`Products:`, products); // Output: Products: [ { id: 'a1', name: 'apple' }, { id: 'b2', name: 'banana' }, { id: 'c3', name: 'orange' } ]
        console.log(`Address: ${nonExistent}`); // Output: Address: N/A

        // Check if data exists
        const hasAge = await db.has('user.age');
        const hasCity = await db.has('user.city');
        console.log(`Has age? ${hasAge}`); // Output: Has age? true
        console.log(`Has city? ${hasCity}`); // Output: Has city? false

        // Delete data
        const deletedAge = await db.delete('user.age');
        console.log(`Was age deleted? ${deletedAge}`); // Output: Was age deleted? true
        console.log(`User data after delete:`, await db.get('user')); // Output: { name: 'Alice' }

    } catch (error) {
        console.error("An error occurred:", error);
    } finally {
        // Important: Close the database when done
        await db.close();
        console.log('Database closed.');
    }
}

main();
</code></pre>
                </section>

                 <!-- Core Concepts Card -->
                <section id="core-concepts" class="card">
                    <h2>Core Concepts</h2>
                    <h3>Atomicity & Locking</h3>
                    <p>
                        All write operations (`set`, `push`, `pull`, `delete`, `transaction`, `batch`, `clear`) are designed to be atomic at the file level. An internal promise-based lock (`writeLock`) ensures that only one write operation executes at a time for a given database instance. Subsequent write attempts queue up and wait for the previous one to complete (read current state, modify, write back, update cache). This prevents race conditions and data corruption.
                    </p>
                    <div class="note">
                        <strong>Note:</strong> High contention (many simultaneous write attempts) can lead to delays as operations wait for the lock. This library is best suited for scenarios without extreme concurrent write loads on the same file.
                    </div>

                    <h3>Caching</h3>
                    <p>
                        The database maintains an in-memory cache (`this.cache`) of the entire JSON file's content for performance.
                    </p>
                    <ul>
                        <li>On instantiation, the database asynchronously loads the file into the cache (`_init`). If the file doesn't exist, it's created with an empty object (`{}`). Operations implicitly wait for this initial load if necessary.</li>
                        <li>Read operations (`get`, `has`, `query`) primarily use this cache (`stats.cacheHits`).</li>
                        <li>Write operations modify a *deep clone* of the cached data, write the *entire* modified data back to the file atomically, and *then* update the in-memory cache with the successfully written state.</li>
                    </ul>
                     <div class="note">
                        <strong>Cache Consistency:</strong> The cache reflects the state after the *last successful write operation completed by this instance*. If the JSON file is modified externally (e.g., by another process), this instance won't automatically detect the change. Rely on the instance's methods for modifications to ensure cache consistency. Manually refreshing the cache is generally discouraged as it bypasses standard locking.
                    </div>

                     <h3>Error Handling</h3>
                     <p>
                         Methods performing I/O or complex operations are `async` and return Promises. Errors during file operations, JSON parsing, or within transaction/batch/query predicates will cause the promise to reject. Use `try...catch` with `await` or `.catch()` on promises to handle errors. The library logs some internal warnings or errors to the console (e.g., file creation issues, batch operation errors, critical write failures). A corrupted JSON file on load will typically cause initialization to fail and throw an error.
                     </p>
                </section>

                <!-- API Reference Card -->
                <section id="api" class="card">
                    <h2>API Reference</h2>

                    <article id="api-constructor">
                        <h3><code>new JSONDatabase(filename, [options])</code></h3>
                        <p>Creates a new database instance linked to a specific JSON file.</p>
                        <h4>Parameters:</h4>
                        <ul class="params">
                            <li><code>filename</code><span class="param-type">(String)</span> - Path to the database file. <code>.json</code> extension added automatically if missing. Relative paths resolved from CWD. Use <code>path.resolve()</code> or <code>path.join(__dirname, ...)</code> for reliability.</li>
                            <li><code>options</code><span class="param-type">(Object)</span><span class="optional">Optional</span> - Configuration options:
                                <ul>
                                    <li><code>prettyPrint</code><span class="param-type">(Boolean)</span><span class="optional">Optional</span> - If <code>true</code>, save JSON with 2-space indentation. Default: <code>false</code> (compact).</li>
                                </ul>
                            </li>
                        </ul>
                        <h4>Behavior:</h4>
                        <ul>
                            <li>Resolves the full file path.</li>
                            <li>Initializes internal state (config, stats).</li>
                            <li>Starts asynchronous loading/creation of the file into the cache. Operations implicitly await this initialization.</li>
                        </ul>
                        <h4>Example:</h4>
                        <pre><code class="language-javascript">const JSONDatabase = require('json-database-st');
const path = require('path');

const db1 = new JSONDatabase('data'); // Targets ./data.json
const db2 = new JSONDatabase('config.json', { prettyPrint: true });
const db3 = new JSONDatabase(path.join(__dirname, 'db', 'app_data')); // Recommended
</code></pre>
                    </article>

                    <article id="api-get">
                        <h3><code>async get(path, [defaultValue])</code></h3>
                        <p>Retrieves the value at a specific lodash path within the JSON data.</p>
                        <h4>Parameters:</h4>
                        <ul class="params">
                            <li><code>path</code><span class="param-type">(String | String[])</span> - The lodash path (e.g., <code>'user.address.city'</code>, <code>['products', 0, 'name']</code>).</li>
                            <li><code>defaultValue</code><span class="param-type">(any)</span><span class="optional">Optional</span> - Value to return if the path does not exist. Defaults to <code>undefined</code>.</li>
                        </ul>
                        <h4>Returns:</h4>
                        <p><code>Promise<any></code> - Resolves with the value found, or the <code>defaultValue</code>.</p>
                        <h4>Behavior:</h4>
                        <ul>
                            <li>Awaits initialization if needed.</li>
                            <li>Reads from the in-memory cache.</li>
                            <li>Uses <code>lodash.get</code>. Increments <code>stats.cacheHits</code>.</li>
                        </ul>
                        <h4>Example:</h4>
                        <pre><code class="language-javascript">// Assuming db contains: { user: { name: 'Bob' }, items: ['a', 'b'] }
const name = await db.get('user.name'); // -> 'Bob'
const firstItem = await db.get(['items', 0]); // -> 'a'
const age = await db.get('user.age', 99); // -> 99
const nonExistent = await db.get('settings.theme'); // -> undefined
</code></pre>
                    </article>

                    <article id="api-set">
                        <h3><code>async set(path, value)</code></h3>
                        <p>Sets or updates the value at a specific lodash path. Atomic write operation.</p>
                        <h4>Parameters:</h4>
                        <ul class="params">
                            <li><code>path</code><span class="param-type">(String | String[])</span> - The lodash path. Intermediate objects/arrays created if needed.</li>
                            <li><code>value</code><span class="param-type">(any)</span> - The JSON-serializable value to set.</li>
                        </ul>
                        <h4>Returns:</h4>
                        <p><code>Promise<void></code> - Resolves when the write is complete.</p>
                        <h4>Behavior:</h4>
                        <ul>
                            <li>Acquires atomic write lock. Reads current state.</li>
                            <li>Uses <code>lodash.set</code> to modify data clone.</li>
                            <li>Writes entire modified data back to file. Updates cache on success.</li>
                            <li>Increments <code>stats.writes</code>.</li>
                        </ul>
                        <h4>Example:</h4>
                        <pre><code class="language-javascript">await db.set('config.theme', 'dark');
await db.set(['users', 'alice', 'roles'], ['admin', 'editor']);
await db.set('products[0].price', 19.99);
</code></pre>
                    </article>

                    <article id="api-push">
                        <h3><code>async push(path, ...items)</code></h3>
                        <p>Adds unique items to an array at the path using deep comparison. Creates array if needed. Atomic write operation.</p>
                        <h4>Parameters:</h4>
                        <ul class="params">
                            <li><code>path</code><span class="param-type">(String | String[])</span> - The lodash path to the target array.</li>
                            <li><code>...items</code><span class="param-type">(any)</span> - One or more items to add.</li>
                        </ul>
                        <h4>Returns:</h4>
                        <p><code>Promise<void></code> - Resolves when the write is complete.</p>
                        <h4>Behavior:</h4>
                        <ul>
                            <li>Atomic write. Gets array at path (or initializes <code>[]</code> if non-existent or not array).</li>
                            <li>For each item, checks if an equivalent item exists using <code>lodash.isEqual</code> (deep comparison).</li>
                            <li>Adds item only if no equivalent exists.</li>
                            <li>Writes back if array was modified. Increments <code>stats.writes</code> if write occurs.</li>
                        </ul>
                        <div class="note">
                            <strong>Deep Comparison:</strong> <code>{ id: 1 }</code> is considered equal to another <code>{ id: 1 }</code> even if they are different object references.
                        </div>
                        <h4>Example:</h4>
                        <pre><code class="language-javascript">await db.set('tags', ['news']);
await db.push('tags', 'sports', 'tech'); // -> ['news', 'sports', 'tech']
await db.push('tags', 'local', 'news'); // -> ['news', 'sports', 'tech', 'local']

await db.push('items', { id: 1 }); // -> [{ id: 1 }]
await db.push('items', { id: 1 }); // -> [{ id: 1 }] (ignored, deep equal)
await db.push('items', { id: 2 }); // -> [{ id: 1 }, { id: 2 }]
</code></pre>
                    </article>

                    <article id="api-pull">
                        <h3><code>async pull(path, ...itemsToRemove)</code></h3>
                        <p>Removes specified items from an array at the path using deep comparison. Atomic write operation.</p>
                        <h4>Parameters:</h4>
                        <ul class="params">
                            <li><code>path</code><span class="param-type">(String | String[])</span> - The lodash path to the target array.</li>
                            <li><code>...itemsToRemove</code><span class="param-type">(any)</span> - Items to remove.</li>
                        </ul>
                        <h4>Returns:</h4>
                        <p><code>Promise<void></code> - Resolves when the write is complete.</p>
                        <h4>Behavior:</h4>
                        <ul>
                            <li>Atomic write. Gets value at path.</li>
                            <li>If not an array, does nothing.</li>
                            <li>If array, uses <code>lodash.pullAllWith</code> and <code>lodash.isEqual</code> to remove all deeply equal items.</li>
                            <li>Writes back if array was modified. Increments <code>stats.writes</code> if write occurs.</li>
                        </ul>
                        <h4>Example:</h4>
                        <pre><code class="language-javascript">await db.set('tasks', ['read', { type: 'code' }, 'sleep', { type: 'code' }]);
await db.pull('tasks', 'read', { type: 'code' }); // -> ['sleep'] (all matching removed)

await db.pull('non_array_path', 'something'); // Does nothing silently
</code></pre>
                    </article>

                    <article id="api-delete">
                        <h3><code>async delete(path)</code></h3>
                        <p>Deletes the property at a specific lodash path. Atomic write operation.</p>
                        <h4>Parameters:</h4>
                        <ul class="params">
                            <li><code>path</code><span class="param-type">(String | String[])</span> - The lodash path to delete.</li>
                        </ul>
                        <h4>Returns:</h4>
                        <p><code>Promise<boolean></code> - Resolves with <code>true</code> if the path existed and was deleted, <code>false</code> otherwise.</p>
                        <h4>Behavior:</h4>
                        <ul>
                            <li>Atomic write. Uses <code>lodash.unset</code>.</li>
                            <li>Writes back the modified data. Returns the boolean result from <code>unset</code>.</li>
                            <li>Increments <code>stats.writes</code>.</li>
                        </ul>
                        <h4>Example:</h4>
                        <pre><code class="language-javascript">await db.set('user', { name: 'Charlie', temporary: true });
const wasDeleted = await db.delete('user.temporary'); // -> true
const data = await db.get('user'); // -> { name: 'Charlie' }
const again = await db.delete('user.temporary'); // -> false
</code></pre>
                    </article>

                    <article id="api-has">
                        <h3><code>async has(path)</code></h3>
                        <p>Checks if a lodash path exists in the data (even if the value is <code>null</code> or <code>undefined</code>).</p>
                        <h4>Parameters:</h4>
                        <ul class="params">
                            <li><code>path</code><span class="param-type">(String | String[])</span> - The lodash path to check.</li>
                        </ul>
                        <h4>Returns:</h4>
                        <p><code>Promise<boolean></code> - Resolves with <code>true</code> if the path exists, <code>false</code> otherwise.</p>
                        <h4>Behavior:</h4>
                        <ul>
                            <li>Awaits initialization if needed. Reads from cache.</li>
                            <li>Uses <code>lodash.has</code>. Increments <code>stats.cacheHits</code>.</li>
                        </ul>
                        <h4>Example:</h4>
                        <pre><code class="language-javascript">// Assuming: { user: { name: 'David', id: null }, config: {} }
const hasName = await db.has('user.name'); // -> true
const hasId = await db.has('user.id'); // -> true
const hasAge = await db.has('user.age'); // -> false
const hasConfig = await db.has('config'); // -> true
</code></pre>
                    </article>

                    <article id="api-transaction">
                        <h3><code>async transaction(asyncFn)</code></h3>
                        <p>Executes an async function with a deep clone of the current data, allowing multiple modifications within a single atomic write.</p>
                        <h4>Parameters:</h4>
                        <ul class="params">
                            <li><code>asyncFn</code><span class="param-type">(Function)</span> - An <code>async (data) => { ...; return modifiedData; }</code> function. It receives a data clone, performs logic, and **must return the data object** to be saved.</li>
                        </ul>
                        <h4>Returns:</h4>
                        <p><code>Promise<object></code> - Resolves with the final database state (the object returned by <code>asyncFn</code>).</p>
                        <h4>Behavior:</h4>
                        <ul>
                            <li>Atomic write. Provides deep clone to <code>asyncFn</code>.</li>
                            <li>If <code>asyncFn</code> completes successfully and returns a data object, that object is written to the file and cache.</li>
                            <li>If <code>asyncFn</code> throws an error, the transaction is aborted, nothing is written.</li>
                            <li>If <code>asyncFn</code> returns <code>undefined</code>, an error is thrown to prevent data loss.</li>
                            <li>Increments <code>stats.writes</code> if write occurs.</li>
                        </ul>
                        <div class="note">
                            <strong>Important:</strong> Ensure your function always returns the data object (either the modified one or the original if no changes should be saved).
                        </div>
                        <h4>Example:</h4>
                        <pre><code class="language-javascript">// Atomically increment a counter
await db.set('stats.visits', 0);
await db.transaction(async (data) => {
  data.stats.visits = (data.stats.visits || 0) + 1;
  return data; // Must return data
});
console.log(await db.get('stats.visits')); // -> 1

// Conditional update
await db.transaction(async (data) => {
  if (data.user?.credits > 10) {
     data.user.credits -= 10;
     data.user.lastDebit = Date.now();
  } // else no changes needed
  return data; // Return data regardless
});
</code></pre>
                    </article>

                    <article id="api-batch">
                        <h3><code>async batch(ops)</code></h3>
                        <p>Performs multiple write operations (`set`, `delete`, `push`, `pull`) together atomically.</p>
                        <h4>Parameters:</h4>
                        <ul class="params">
                            <li><code>ops</code><span class="param-type">(Array<Object>)</span> - Array of operation objects:
                                <ul>
                                    <li><code>{ type: 'set', path: String|String[], value: any }</code></li>
                                    <li><code>{ type: 'delete', path: String|String[] }</code></li>
                                    <li><code>{ type: 'push', path: String|String[], values: Array<any> }</code> (deep unique)</li>
                                    <li><code>{ type: 'pull', path: String|String[], values: Array<any> }</code> (deep removal)</li>
                                </ul>
                            </li>
                        </ul>
                         <h4>Returns:</h4>
                        <p><code>Promise<void></code> - Resolves when the batch write is complete.</p>
                        <h4>Behavior:</h4>
                        <ul>
                            <li>Single atomic write lock. Reads data once.</li>
                            <li>Applies operations sequentially to the data clone.</li>
                            <li>Logs errors for invalid/failed individual operations but continues by default.</li>
                            <li>Writes the final state back once. Updates cache.</li>
                            <li>Increments <code>stats.writes</code> once for the entire batch.</li>
                        </ul>
                         <div class="note">
                            <strong>Efficiency:</strong> More efficient than multiple individual write calls due to single read/write cycle.
                        </div>
                        <h4>Example:</h4>
                        <pre><code class="language-javascript">await db.batch([
  { type: 'set', path: 'config.updated', value: true },
  { type: 'push', path: 'log', values: [`Batch update at ${Date.now()}`] },
  { type: 'pull', path: 'features', values: [{ id: 'beta' }] }, // deep compare pull
  { type: 'delete', path: 'temp.data' }
]);
</code></pre>
                    </article>

                    <article id="api-query">
                        <h3><code>async query(predicate, [options])</code></h3>
                        <p>Queries the direct properties of an object (root or at `basePath`), returning values that satisfy the predicate.</p>
                        <h4>Parameters:</h4>
                        <ul class="params">
                            <li><code>predicate</code><span class="param-type">(Function)</span> - Function `(value, key) => boolean`. Returns `true` to include the `value`.</li>
                            <li><code>options</code><span class="param-type">(Object)</span><span class="optional">Optional</span> - Query options:
                                <ul>
                                    <li><code>basePath</code><span class="param-type">(String | String[])</span><span class="optional">Optional</span> - Lodash path to the object whose properties should be queried. If omitted, queries root object properties.</li>
                                    <li><code>limit</code><span class="param-type">(Number)</span><span class="optional">Optional</span> - Maximum number of result values to return.</li>
                                </ul>
                            </li>
                        </ul>
                        <h4>Returns:</h4>
                        <p><code>Promise<Array<any>></code> - Resolves with an array of the **values** that passed the predicate.</p>
                        <h4>Behavior:</h4>
                        <ul>
                            <li>Awaits initialization. Reads from cache.</li>
                            <li>Gets the object at `basePath` (or root). Must be a plain object.</li>
                            <li>Iterates over the object's own properties.</li>
                            <li>Calls `predicate(value, key)`. Collects `value` if predicate returns `true`.</li>
                            <li>Applies `limit`.</li>
                        </ul>
                        <h4>Example:</h4>
                        <pre><code class="language-javascript">// Assuming: { users: { 'u1': { age: 30, active: true }, 'u2': { age: 25, active: false } }, ... }
// Find active users' data
const activeUsers = await db.query(
    (userValue) => userValue.active === true,
    { basePath: 'users' }
); // -> [ { age: 30, active: true }, ... ] (Array of user objects)

// Find top-level configs (values only)
const configs = await db.query(
    (value, key) => key.startsWith('config')
); // -> [ { theme: 'dark'}, { region: 'eu' } ]
</code></pre>
                    </article>

                     <article id="api-clear">
                        <h3><code>async clear()</code></h3>
                        <p>Clears all data, replacing file content with <code>{}</code>. Atomic write. Use with caution!</p>
                        <h4>Parameters:</h4>
                        <p>None.</p>
                        <h4>Returns:</h4>
                        <p><code>Promise<void></code> - Resolves when the clear operation is complete.</p>
                        <h4>Behavior:</h4>
                        <ul>
                            <li>Atomic write. Sets data to <code>{}</code>. Writes file. Updates cache.</li>
                            <li>Logs a warning. Increments <code>stats.writes</code>.</li>
                        </ul>
                        <h4>Example:</h4>
                        <pre><code class="language-javascript">await db.set('user.name', 'Temp');
await db.clear(); // Logs warning
console.log(await db.get('.')); // -> {}
</code></pre>
                    </article>

                    <article id="api-getstats">
                         <h3><code>getStats()</code></h3>
                         <p>Returns an object with current operational statistics for this instance.</p>
                         <h4>Parameters:</h4>
                         <p>None.</p>
                          <h4>Returns:</h4>
                         <p><code>Object</code> - Contains:</p>
                         <ul class="props">
                             <li><code>reads</code><span class="prop-type">(Number)</span> - File reads.</li>
                             <li><code>writes</code><span class="prop-type">(Number)</span> - File writes (atomic operations).</li>
                             <li><code>cacheHits</code><span class="prop-type">(Number)</span> - Cache reads (`get`, `has`, `query`).</li>
                         </ul>
                         <h4>Behavior:</h4>
                         <ul>
                             <li>Synchronously returns a copy of the internal stats.</li>
                         </ul>
                         <h4>Example:</h4>
                         <pre><code class="language-javascript">const stats = db.getStats();
console.log(`DB Stats: Reads=${stats.reads}, Writes=${stats.writes}, Cache Hits=${stats.cacheHits}`);
</code></pre>
                     </article>

                    <article id="api-close">
                        <h3><code>async close()</code></h3>
                        <p>Waits for pending writes, clears cache, and releases lock. Call before application exit.</p>
                        <h4>Parameters:</h4>
                        <p>None.</p>
                         <h4>Returns:</h4>
                        <p><code>Promise<void></code> - Resolves when closed.</p>
                        <h4>Behavior:</h4>
                        <ul>
                            <li>Awaits completion of the current write lock chain.</li>
                            <li>Sets internal cache and lock references to <code>null</code>.</li>
                            <li>Logs a confirmation message with final stats.</li>
                        </ul>
                        <div class="note">
                            <strong>Important:</strong> Guarantees pending data is written before clearing internal state. Operations after close may fail or re-initialize.
                        </div>
                        <h4>Example:</h4>
                        <pre><code class="language-javascript">await db.set('status', 'shutting down');
await db.close(); // Waits for set to finish writing
console.log('Application finished.');
</code></pre>
                    </article>
                </section>

                <!-- Properties Card -->
                <section id="properties" class="card">
                    <h2>Properties</h2>
                    <p>These properties are primarily for information and configuration:</p>
                    <ul class="props">
                        <li><code>filename</code><span class="prop-type">(String)</span> - The fully resolved, absolute path to the JSON database file.</li>
                        <li><code>config</code><span class="prop-type">(Object)</span> - The configuration object (contains <code>prettyPrint</code> setting).</li>
                    </ul>
                     <div class="note">
                         <strong>Internal State:</strong> Properties like <code>cache</code>, <code>writeLock</code>, <code>stats</code> are managed internally. Use methods like <code>getStats()</code> or <code>close()</code> instead of direct manipulation.
                     </div>
                     <h4>Example: Accessing Properties</h4>
                     <pre><code class="language-javascript">const db = new JSONDatabase('app_data', { prettyPrint: true });
// ... after some operations ...

console.log(`Database file: ${db.filename}`);
console.log(`Pretty print enabled: ${db.config.prettyPrint}`);

const currentStats = db.getStats(); // Use the method for stats
console.log(`Current Stats:`, currentStats);
</code></pre>
                </section>

            </div>
        </main>
    </div> <!-- End Content Wrapper -->

    <footer>
        <div class="container">
            Simple JSON DB Documentation | <a href="https://github.com/<your-github-username>/<repo-name>" target="_blank" rel="noopener">GitHub Repository</a>
            <!-- Replace <your-github-username>/<repo-name> -->
        </div>
    </footer>

    <!-- Prism.js Core & JS Language Component -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>

    <!-- Simple Sidebar Toggle Script -->
    <script>
        const menuToggle = document.getElementById('menu-toggle');
        const body = document.body;
        const sidebar = document.getElementById('sidebar');

        if (menuToggle) {
            menuToggle.addEventListener('click', () => {
                body.classList.toggle('sidebar-open');
            });
        }
        // Close sidebar when clicking on the main content overlay
         body.addEventListener('click', function(event) {
             if (body.classList.contains('sidebar-open') && !sidebar.contains(event.target) && !menuToggle.contains(event.target)) {
                body.classList.remove('sidebar-open');
             }
         });
         // Close sidebar when a nav link is clicked (on mobile)
         sidebar.querySelectorAll('a').forEach(link => {
            link.addEventListener('click', () => {
                 if (window.innerWidth <= 992 && body.classList.contains('sidebar-open')) {
                      body.classList.remove('sidebar-open');
                 }
            });
         });
    </script>
</body>
</html>
