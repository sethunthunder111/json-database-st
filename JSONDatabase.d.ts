// Type definitions for json-database-st
// Project: https://github.com/sethunthunder111/json-database-st
// Definitions: autogenerated

declare namespace JSONDatabase {
  type Operation = 'set' | 'delete' | 'push' | 'pull' | 'transaction' | 'batch';

  interface IndexDefinition {
    name: string;
    path: string | string[];
    field: string;
    unique?: boolean;
  }

  interface BatchOperationSet { type: 'set'; path: string | string[]; value: any }
  interface BatchOperationDelete { type: 'delete'; path: string | string[] }
  interface BatchOperationPush { type: 'push'; path: string | string[]; values: any[] }
  interface BatchOperationPull { type: 'pull'; path: string | string[]; values: any[] }
  type BatchOperation =
    | BatchOperationSet
    | BatchOperationDelete
    | BatchOperationPush
    | BatchOperationPull;

  interface JSONDatabaseOptions {
    encryptionKey?: string | null;
    prettyPrint?: boolean;
    writeOnChange?: boolean;
    schema?: {
      safeParse(data: unknown):
        | { success: true; data: unknown }
        | { success: false; error: { issues?: unknown } };
    } | null;
    indices?: IndexDefinition[];
  }

  interface WriteEvent { filename: string; timestamp: number }
  interface ChangeEvent { oldValue: any; newValue: any }
  interface BatchOptions { stopOnError?: boolean }
}

declare class JSONDatabase extends import('events').EventEmitter {
  constructor(filename: string, options?: JSONDatabase.JSONDatabaseOptions);

  get<T = any>(path?: string | string[], defaultValue?: T): Promise<T>;
  has(path: string | string[]): Promise<boolean>;
  set<T = any>(path: string | string[], value: T): Promise<any>;
  delete(path: string | string[]): Promise<boolean>;

  push<T = any>(path: string | string[], ...items: T[]): Promise<any | undefined>;
  pull<T = any>(path: string | string[], ...itemsToRemove: T[]): Promise<any | undefined>;

  transaction<T>(transactionFn: (data: any) => T | Promise<T>): Promise<T>;
  batch(
    ops: JSONDatabase.BatchOperation[],
    options?: JSONDatabase.BatchOptions
  ): Promise<any | undefined>;

  find<T = any>(
    collectionPath: string | string[],
    predicate: (value: any, key?: any) => boolean
  ): Promise<T | undefined>;
  findByIndex<T = any>(indexName: string, value: any): Promise<T | undefined>;

  clear(): Promise<any>;
  getStats(): { reads: number; writes: number; cacheHits: number };
  close(): Promise<void>;

  before(
    operation: JSONDatabase.Operation,
    pathPattern: string,
    callback: (context: any) => any
  ): void;
  after(
    operation: JSONDatabase.Operation,
    pathPattern: string,
    callback: (context: any) => any
  ): void;

  on(event: 'write', listener: (event: JSONDatabase.WriteEvent) => void): this;
  on(event: 'change', listener: (event: JSONDatabase.ChangeEvent) => void): this;
  on(event: 'error', listener: (error: Error) => void): this;
  on(event: string, listener: (...args: any[]) => void): this;

  once(event: 'write', listener: (event: JSONDatabase.WriteEvent) => void): this;
  once(event: 'change', listener: (event: JSONDatabase.ChangeEvent) => void): this;
  once(event: 'error', listener: (error: Error) => void): this;
  once(event: string, listener: (...args: any[]) => void): this;
}

export = JSONDatabase;
